#include "CurrentBDC.h"
#include "main.h"

#define Vadc_mVolt 3300
#define Rshunt_mOhm 25
#define KgOpAmp 10
#define K_filter 32
#define Current_MAX_mAmp 3000

uint16_t ADC_Data = 0;
uint16_t wait_loop_index = 0;
uint16_t ADCAL_Time = 0;
uint16_t ADC_mVolt = 0;
uint32_t BDC_mAmp = 0;
uint32_t Filter_out = 0;
uint32_t BDC_mAmp_filtered = 0;


/*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓*/
//Старт                                                                      ┃
void CurrentBDC_StartUp(void)//                                              ┃
/*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛*/
{
/*
2.4.6 Калибровка (ADCAL, ADCALDIF, ADC_CALFACT)
  Каждый АЦП обеспечивает автоматическую процедуру калибровки, которая управляет всей последовательностью калибровки,
включая последовательность включения/выключения питания АЦП. Во время процедуры АЦП вычисляет калибровочный
коэффициент шириной 7 бит, который применяется внутри АЦП до следующего отключения питания АЦП. Во время процедуры
калибровки приложение не должно использовать АЦП и должно дождаться завершения калибровки.
  Калибровка является предварительной перед любой операцией АЦП. Это устраняет ошибку смещения, которая может изменяться
от чипа к чипу из-за изменения технологического процесса или запрещенной зоны.
  Калибровочный коэффициент, применяемый для односторонних входных преобразований, отличается от коэффициента,
применяемого для дифференциальных входных преобразований:
  • Запишите ADCALDIF=0 перед запуском калибровки, которая будет применена для однократных входных преобразований.
  • Запишите ADCALDIF=1 перед запуском калибровки, которая будет применена для дифференциальных входных преобразований.
  Затем калибровка инициируется программным обеспечением путем установки бита ADCAL=1. 
  Калибровка может быть выполнена только когда АЦП отключен (когда ADEN=0).
  Бит АЦП остается равным 1 в течение всей последовательности калибровки.
  Затем он очищается аппаратным обеспечением, как только калибровка завершается.
  В это время соответствующий калибровочный коэффициент хранится внутри аналогового АЦП, а также в
битах CALFACT_S[6:0] или CALFACT_D[6:0] регистра ADC_CALFACT (в зависимости от
калибровки одностороннего или дифференциального входа).
Внутренняя аналоговая калибровка сохраняется, если АЦП отключен (ADEN=0). При
изменении условий работы АЦП (изменения VREF+ являются основным фактором, влияющим на смещение АЦП
вариации, VDDA и изменение температуры в меньшей степени), рекомендуется повторно запустить
цикл калибровки.
Внутренняя аналоговая калибровка теряется при каждом отключении питания АЦП (например,
когда устройство переходит в режим ожидания или VBAT). В этом случае, чтобы избежать затрат времени
на повторную калибровку АЦП, можно переписать калибровочный коэффициент в
регистр ADC_CALFACT без повторной калибровки, предполагая, что программное обеспечение предварительно сохранило
калибровочный коэффициент, полученный во время предыдущей калибровки.
Калибровочный коэффициент может быть записан, если АЦП включен, но не преобразует (ADEN=1 и
ADSTART=0 и JADSTART=0). Затем, при следующем запуске преобразования, значение калибровки
будет автоматически введено в аналоговый АЦП. Эта загрузка прозрачна и не
добавляет никакой задержки цикла к началу преобразования.
Процедура программного обеспечения для калибровки АЦП
1. Убедитесь, что значение ADVREGEN[1:0]=01 и что время запуска регулятора напряжения АЦП истекло.
2. Убедитесь, что ADEN=0.
3. Выберите режим ввода для этой калибровки, установив ADCALDIF=0 (односторонний вход).
или ADCALDIF=1 (дифференциальный вход).
4. Установите ADCAL=1.
5. Подождите, пока ADCAL не станет равным 0.
6. Калибровочный коэффициент можно считывать из регистра ADC_CALFACT
*/
  LL_ADC_StartCalibration(ADC1);
  while (LL_ADC_IsCalibrationOnGoing(ADC1) != 0)
  {
    ADCAL_Time++;
  }
  LL_ADC_Enable(ADC1);
  wait_loop_index = ((LL_ADC_DELAY_CALIB_ENABLE_ADC_CYCLES * 32) >> 1);
  while(wait_loop_index != 0)
  {
    wait_loop_index--;
  }
}
/*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓*/
//Получить значение тока BDC                                                 ┃
void CurrentBDC_GET(void)//                                                  ┃
/*━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛*/
{
  LL_ADC_REG_StartConversion(ADC1);
  while (!LL_ADC_IsActiveFlag_EOS(ADC1))  {}
  LL_ADC_ClearFlag_EOS(ADC1);
  ADC_Data = LL_ADC_REG_ReadConversionData12(ADC1);
  ADC_mVolt = __LL_ADC_CALC_DATA_TO_VOLTAGE((uint32_t)Vadc_mVolt, ADC_Data, LL_ADC_RESOLUTION_12B);
  BDC_mAmp = ADC_mVolt * 1000 / Rshunt_mOhm / KgOpAmp;
  Filter_out -= Filter_out / K_filter;
  Filter_out += BDC_mAmp;
  BDC_mAmp_filtered =  Filter_out / K_filter;
  if (BDC_mAmp_filtered > Current_MAX_mAmp)
  {
    GLOBAL_FLAG_TX |= BDC_CURRENT_LIMIT_FLAG;
  }
}
